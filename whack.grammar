character : /'.'/ ;

integral : /[0-9]+/ ;

binary : "0b"/[0-1]+/ ;

octal : "0o"/[0-7]+/ ;

hexadecimal : "0x"/[0-9a-fA-F]+/ ;

floatingpt : /[0-9]+['.'][0-9]*/ ;

boolean : "true"
        | "false" ;

string : /\"(\\\\.|[^\"])*\"/ ;

ident   : /[a-zA-Z_][a-zA-Z0-9_]*/ ;

identlist : <ident> (',' <ident>)* ;

scoperes : <ident> ("::" <ident>)+ ;

simplesymbolname : <scoperes>
                 | <ident> ;

overloadid : <simplesymbolname> "::" <structopname> ;

identifier : <overloadid>
           | <simplesymbolname> ;

factor : ('(' <expression> ')')
       | (('!' | '*' | '+' | '-' | '~') <factor>)
       | <matchexpr>
       | <closure>
       | <newexpr>
       | <sizeofval>
       | <alignofval>
       | <offsetofval>
       | <cast>
       | <funccall>
       | <expansion>
       | <expandop>
       | <preop>
       | <postop>
       | <value>
       | <memberinitlist>
       | <initlist>
       | <character>
       | <floatingpt>
       | <binary>
       | <octal>
       | <hexadecimal>
       | <integral>
       | <boolean>
       | <string>
       | <reference>
       | <element>
       | <structmember>
       | <identifier> ;

arraytype   : '[' <expression> ']' <type> ;

fntype      : "func" '(' ((<typelist> ("->" <typelist>)?) | ("()" "->" <typelist>))? ')' ;

exprtype    : "type" '(' <expression> ')' ;

basictypes  : <fntype>
            | <exprtype>
            | <arraytype>
            | <identifier> ;

pointertype : <basictypes> '*'+ ;

type        : (<pointertype> | <basictypes>) '&'? ;

typeident   : <type> <ident> ;

variadicarg : <variadictype> <ident> ;

args        : <variadicarg>
            | <typeident> (',' <typeident>)* (',' <variadicarg>)? ;

variadictype : <type> <expansion> ;

typelist    : <variadictype>
            | <type> (',' <type>)* (',' <variadictype>)? ;

capture : '&' | '=' | (<ident> ('&' | ('=' <expression>))?) ;

closure : "func" ('[' (<capture> (',' <capture>)*)? ']')? '(' <args>? ')' <typelist>? <body> ;

newexpr : "new" ('(' <expression> ')')? <type> <initializer>? ;

sizeofval : "sizeof" '(' <type> ')' ;

multiplicative : <factor> (('/' | '*' | '%') <factor>)* ;

additive : <multiplicative> (('+' | '-') <multiplicative>)* ;

shift : <additive> (("<<" | ">>") <additive>)* ;

relational : <shift> (("<=" | '<' | ">=" | '>') <shift>)* ;

equality : <relational> (("==" | "!=") <relational>)* ;

bitwiseand : <equality> ('&' <equality>)* ;

bitwisexor : <bitwiseand> ('^' <bitwiseand>)* ;

bitwiseor : <bitwisexor> ('|' <bitwisexor>)* ;

logicaland : <bitwiseor> ("&&" <bitwiseor>)* ;

logicalor : <logicaland> ("||" <logicaland>)* ;

callable : <closure>
         | <overloadid>
         | <scoperes>
         | <variable> ;

funccall : ("await" | "async")?
           <callable> ("->" <callable>)* ('(' <exprlist>? ')')+ ;

initlist : '{' <exprlist>? '}' ;

memberinitlist : <ident> ':' <expression> (',' <ident> ':' <expression>)* ;

initializer : '{' <memberinitlist> '}'
            | <initlist> ;

value : <type> <initializer> ;

alignofval : "alignof" '(' <type> ')' ;

offsetofval : "offsetof" '(' <type> ',' <ident> ')' ;

cast : "cast" '<' <type> '>' '(' <expression> ')' ;

expansion : "..." ;

expandop : <variable> <expansion> ;

reference : <variable> '&' ;

structmembercont : <ident> '.' ;

structmember : <structmembercont> (<structopname> | <ident>) ;

elementcont : <ident> '[' ;

element : <elementcont> <expression> ']' ;

variable : <element>
         | <structmember>
         | <ident> ;

range : <factor> (".." (<factor> "..")? ('='? <factor>)?)? ;

preop : ("--" | "++") <variable> ;

postop : <variable> ("--" | "++") ;

ternary : <logicalor> '?' <expression> ':' <expression> ;

addrof : '&' <factor> ;

exprlist : <expression> (',' <expression>)* ;

matchexprcase : <exprlist> ':' <expression> ;

matchexpr : "match" <expression> '{'
              (<matchexprcase> (';' <matchexprcase>)*)?
              "default" ':' <expression>
            '}' ;

expression : <addrof>
           | <ternary>
           | <logicalor> ;

let : "let" "mut"? <identlist> '=' <exprlist> ;

alias : "using" <identlist> '=' <typelist> ';'? ;

match   : "match" <expression> '{'
            (<exprlist> ':' <stmt>)*
            ("default" ':' <stmt>)?
          '}' ;

typeswitch : "match" <exprtype> '{'
                (<typelist> ':' <stmt>)*
                ("default" ':' <stmt>)?
              '}' ;

assign : <factor> (',' <factor>)* '=' <exprlist> ;

letbind : "let" <simplesymbolname> '(' <identlist> ')' '=' <expression> ;

ifstmt : "if" (<letbind> | <logicalor>) <stmt> ("else" <stmt>)? ;

forinexpr : "for" <identlist> "in" <range> ("if" <logicalor>)? ;

forincrexpr : "for" (<stmt>+ | ';') <logicalor> ';' <stmt>* ;

forexpr : <forinexpr>
        | <forincrexpr> ;

forstmt : <forexpr> <stmt> ;

whilestmt : "while" <logicalor> <stmt> ;

opeq : <variable> ('&' | '|' | '+' | '-' | '^' | '%' | '/' | '*' | ">>" | "<<") '=' <expression> ;

declassign : <typeident> <initializer>? (',' <ident> <initializer>?)* ;

returnstmt : "return" <exprlist>? ;

deletestmt : "delete" <exprlist> ;

yieldstmt : "yield" <exprlist>? ;

breakstmt : "break" ;

continuestmt : "continue" ;

unreachablestmt : "unreachable" ;

deferstmt : "defer" <stmt> ;

stmt : <body>
     | <typeswitch>
     | <match>
     | <ifstmt>
     | <whilestmt>
     | <forstmt>
     | <structure>
     | <enumeration>
     | <dataclass>
     | <comment>
     | <alias>
     | (  <yieldstmt>
         | <returnstmt>
         | <deletestmt>
         | <unreachablestmt>
         | <breakstmt>
         | <continuestmt>
         | <deferstmt>
         | <let>
         | <assign>
         | <declassign>
         | <opeq>
         | <funccall>
         | <newexpr>
         | <preop>
         | <postop>
        ) ';'? ;

body        : <tags>? '{' <stmt>* '}' ;

tag         : <simplesymbolname> ('(' <exprlist> ')')? ;

tags        : ('@' <tag>)
            | ('@' '(' <tag> (',' <tag>)* ')') ;

classdef    : "class" '{'
                 (<ident> '(' <typelist>? ')')+
              '}' ;

enumdef     : "enum" (':' <ident>)? '{' <identlist> '}' ;

enumeration : <ident> <enumdef> ;

dataclass   : <ident> <classdef> ;

function    : "func" (("operator" <overloadableops>) | <ident>) '(' <args>? ')' <typelist>? <body> ;

structdef   : "struct" <tags>? '{'
                (<tags>? <declassign> ';'?)*
              '}' ;

structure   : <ident> <structdef> ;

overloadableops : "<<="
                | ">>="
                | "&&"
                | "||"
                | "<<"
                | ">>"
                | ">="
                | "<"
                | ">"
                | "!="
                | "=="
                | "-="
                | "+="
                | "|="
                | "/="
                | "%="
                | "&="
                | "^="
                | "*="
                | "|"
                | "!"
                | "~"
                | "="
                | "/"
                | "*"
                | "--"
                | "-"
                | "++"
                | "+"
                | "()"
                | "[]" ;

newoperator  : "operator" "new" "[]"? ;

structopname : "operator" (<type> | <overloadableops>) ;

structop    : "func" '(' "mut"? <ident> ')'
                 <structopname> '(' (<args> | <typelist>)? ')' <type>?
                 (<body> | ('=' "default")) ;

structfunc  : "func" '(' "mut"? <ident> ')'
                <ident> '(' <args>? ')' <typelist>?
                (<body> | ('=' "default")) ;

structmembername : <structopname>
                 | <ident> ;

interfacedef   : "interface" (':' <simplesymbolname> (',' <simplesymbolname>)*)? '{'
                   (<fntype> <structmembername>)+
                 '}' ;

interface   : <ident> <interfacedef> ;

externfunc  : "extern" <fntype> <ident> ';'? ;

exports     : "export" <identlist> ';'? ;

moduleuse   : "use" <simplesymbolname> ('!'? '{' <identlist> '}')? ("as" <ident>)? ';'? ;

moduledecl  : "module" <ident> ';'? ;

compileropt : "{-" "OPTIONS" <identlist> "-}" ;

comment     : "//" /[^'\n']+/ | /[\n]/ ;

whack       : /^/ (<compileropt> | <comment>)*
                  <moduledecl>
                  (<moduleuse> | <comment>)*
                  (
                      <comment>
                    | <externfunc>
                    | <exports>
                    | <dataclass>
                    | <interface>
                    | <enumeration>
                    | <structure>
                    | <structfunc>
                    | <structop>
                    | <alias>
                    | <function>
                  )*
              /$/ ;
